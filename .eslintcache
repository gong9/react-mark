[{"D:\\mycode\\react-mark\\src\\index.js":"1","D:\\mycode\\react-mark\\src\\App.js":"2","D:\\mycode\\react-mark\\src\\mark\\index.jsx":"3","D:\\mycode\\react-mark\\src\\util.js\\getDomRange.js":"4"},{"size":178,"mtime":1611214441914,"results":"5","hashOfConfig":"6"},{"size":2249,"mtime":1612181800426,"results":"7","hashOfConfig":"6"},{"size":11846,"mtime":1612183663309,"results":"8","hashOfConfig":"6"},{"size":188,"mtime":1611215411106,"results":"9","hashOfConfig":"6"},{"filePath":"10","messages":"11","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"12"},"1mozqqh",{"filePath":"13","messages":"14","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"12"},{"filePath":"15","messages":"16","errorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"17","usedDeprecatedRules":"12"},{"filePath":"18","messages":"19","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"20"},"D:\\mycode\\react-mark\\src\\index.js",[],["21","22"],"D:\\mycode\\react-mark\\src\\App.js",[],"D:\\mycode\\react-mark\\src\\mark\\index.jsx",["23","24","25","26","27","28","29","30","31","32","33"],"import React, { useEffect, useRef } from 'react';\r\nimport { getDomRange } from '../util.js/getDomRange.js'\r\nimport './index.css'\r\n\r\nconst Mark = (props) => {\r\n    const { children } = props\r\n    const markRef = useRef()\r\n\r\n\r\n    useEffect(() => {\r\n        if (localStorage.getItem('markDom')) {\r\n            JSON.parse(localStorage.getItem('markDom')).forEach(\r\n                node => {\r\n                    console.log(node)\r\n                    console.log(parseToDOM(deSerialize(node)))\r\n                }\r\n            )\r\n        }\r\n    })\r\n    let allMarkArr = []\r\n    let markArr = []\r\n    let data = []\r\n    let flag = 0\r\n    let allTextNode = []\r\n    useEffect(() => {\r\n        allMarkArr = []\r\n    }, [])\r\n\r\n    /**\r\n     * \r\n     * @param {*} node\r\n     * è¿›è¡ŒåŒ…è£¹ \r\n     */\r\n    const parseToDOM = (node) => {\r\n\r\n        const parentNode = node.parentNode\r\n        // è¿™ä¸ªæƒ…å†µæˆ‘ç°åœ¨ä¹Ÿä¸çŸ¥é“æ˜¯å“ªé‡Œå‡ºæ¥çš„bug\r\n        if (parentNode) {\r\n            const span = document.createElement(\"span\");\r\n            const newNode = node.cloneNode(true);\r\n            span.appendChild(newNode)\r\n            span.className = 'mark'\r\n            parentNode.replaceChild(span, node)\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * è·å–é€‰å–çš„domä¿¡æ¯\r\n     */\r\n    const electoral = () => {\r\n\r\n        markArr = []\r\n        flag = 0\r\n        let range = getDomRange()\r\n\r\n        if (range) {\r\n            // è·å–èµ·å§‹ä½ç½®å’Œç»ˆæ­¢ä½ç½®\r\n            const start = {\r\n                node: range.startContainer,\r\n                offset: range.startOffset\r\n            }\r\n            const end = {\r\n                node: range.endContainer,\r\n                offset: range.endOffset\r\n            }\r\n            // 2. å¤„ç†å¤´å°¾\r\n            // é¦–å°¾æ˜¯ä¸€ä¸ªèŠ‚ç‚¹çš„æƒ…å†µ,åº”è¯¥æ˜¯å–ä¸€ä¸ªäº¤é›†\r\n            let newNode\r\n            if (start.node === end.node) {\r\n\r\n                newNode = splitNode(start.node, start.offset, end.offset)\r\n                data.push(serialize(newNode))\r\n                parseToDOM(newNode)\r\n\r\n\r\n            } else {\r\n                // å¤šèŠ‚ç‚¹çš„æ—¶å€™å°±éœ€è¦æ”¶é›†ä¸€æ¬¡äº†\r\n                traversalDom(start, end)\r\n\r\n                markArr[0] = splitHeader(start)\r\n                markArr[markArr.length - 1] = splitTail(end)\r\n                markArr.forEach(node => data.push(serialize(node)))\r\n                markArr.forEach(node => {\r\n                    parseToDOM(node)\r\n                })\r\n\r\n            }\r\n            localStorage.setItem('markDom', JSON.stringify(data))\r\n        }\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {*} textNode \r\n     * @param {*} root \r\n     * å¼€å§‹è¿›è¡ŒDOMçš„åºåˆ—åŒ–\r\n     */\r\n    const serialize = (textNode, root = document) => {\r\n\r\n        // è¿™é‡Œè¦æ€ä¹ˆå†™å‘¢ï¼Ÿ\r\n        // è®°å½•æ¯ä¸€ä¸ªæ–‡æœ¬èŠ‚ç‚¹çš„å…·ä½“ä½ç½®ï¼Œæ€ä¹ˆè®°å½•å‘¢ï¼Ÿ \r\n        //childIndex æ˜¯åœ¨\r\n        allTextNode = []\r\n        const node = findFatherNode(textNode)\r\n        getAllTextNode(node)\r\n\r\n        // æ‹¿è¯¥æ–‡æœ¬èŠ‚ç‚¹åœ¨ä»–çˆ¶äº²ç§çš„æ‰€æœ‰æ–‡æœ¬èŠ‚ç‚¹çš„å‰ååç§»é‡\r\n        let childIndexStart = -1\r\n        let childIndexend = -1\r\n        let childIndex = -1\r\n\r\n\r\n        // è®¡ç®—å‰ç½®åç§»\r\n        const calcLeftLength = (index) => {\r\n\r\n            let length = 0\r\n            for (let i = 0; i < index; i++) {\r\n                length = length + allTextNode[i].length\r\n            }\r\n            return length\r\n        }\r\n\r\n        // è®¡ç®—åç½®åç§»\r\n        const calcRightLength = (index) => {\r\n\r\n            let length = 0\r\n            for (let i = index + 1; i < allTextNode.length; i++) {\r\n                length = length + allTextNode[index].length\r\n            }\r\n            return length\r\n        }\r\n\r\n\r\n        let Index = allTextNode.findIndex(textnode => textnode === textNode)\r\n        if (Index === 0) {\r\n            childIndexStart = 0     //å‰åç§»\r\n            childIndexend = calcLeftLength(Index + 1)   //ååç§»\r\n        } else if (Index === allTextNode.length - 1) {\r\n            childIndexStart = calcLeftLength(Index)\r\n            childIndexend = calcLeftLength(Index + 1)\r\n        } else {\r\n            childIndexStart = calcLeftLength(Index)\r\n            childIndexend = calcLeftLength(Index + 1)\r\n        }\r\n\r\n        // æ‰¾å‡ºè¿™ä¸ªæ–‡æœ¬èŠ‚ç‚¹æ˜¯å…¶çˆ¶èŠ‚ç‚¹çš„ç¬¬å‡ ä¸ªå­©å­\r\n        // for (let i = 0; i < node.childNodes.length; i++) {\r\n        //     if (node.childNode[i] === textNode) {\r\n        //         childIndex = i\r\n        //     }\r\n        // }\r\n        // é€šè¿‡å®ƒçˆ¶äº²çš„èŠ‚ç‚¹è¿›è¡Œå®šä½å°±å¯ä»¥ğŸ˜¬\r\n        const tagName = node.tagName\r\n        const list = root.getElementsByTagName(tagName)\r\n        for (let index = 0; index < list.length; index++) {\r\n            if (node === list[index]) {\r\n                return { tagName, index, childIndexStart, childIndexend }\r\n            }\r\n        }\r\n        return { tagName, index: -1, childIndexStart, childIndexend }\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {*} proNode \r\n     * è·å–å…¨éƒ¨æ–‡æœ¬èŠ‚ç‚¹ï¼Œè¿˜æ˜¯dfs\r\n     */\r\n    const getAllTextNode = (proNode) => {\r\n        if (!proNode.childNodes) return\r\n        for (let i = 0; i < proNode.childNodes.length; i++) {\r\n            if (proNode.childNodes[i].nodeType === 3) {\r\n                allTextNode.push(proNode.childNodes[i])\r\n            } else {\r\n                getAllTextNode(proNode.childNodes[i])\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {*} meta \r\n     * @param {*} root \r\n     * ååºåˆ—åŒ–\r\n     */\r\n    const deSerialize = (meta, root = document) => {\r\n        const { tagName, index, childIndexStart, childIndexend } = meta\r\n        const parent = root.getElementsByTagName(tagName)[index]\r\n\r\n        allTextNode = []\r\n        getAllTextNode(parent)\r\n        console.log(allTextNode)\r\n        let nodeIndexStart = -1\r\n        let nodeIndexEnd = -1\r\n\r\n        // è¿™é‡Œéœ€è¦æ‰¾ä¸€ä¸ªåŒºé—´\r\n        // æœ‰å·¦å³åç§»é‡çš„æƒ…å†µï¼Œå¤„ç†å·¦å³åç§»é‡\r\n        let length = 0\r\n        let length2 = 0\r\n        let length3 = 0\r\n        for (let i = 0; i < allTextNode.length; i++) {\r\n            length = length + allTextNode[i].length\r\n            if (length >= childIndexStart) {\r\n                nodeIndexStart = i\r\n                break;\r\n            }\r\n        }\r\n        console.log(nodeIndexStart)\r\n        for (let j = 0; j < allTextNode.length; j++) {\r\n            length2 = length2 + allTextNode[j].length\r\n            if (length2 >= childIndexend) {\r\n                nodeIndexEnd = j\r\n                break;\r\n            }\r\n        }\r\n\r\n        const calcLeftLength = (index) => {\r\n            let length = 0\r\n            for (let i = 0; i < index; i++) {\r\n                length = length + allTextNode[i].length\r\n            }\r\n            return length\r\n        }\r\n        length3 = calcLeftLength(nodeIndexStart)\r\n\r\n        // ä¸‹é¢åˆæ˜¯ä¸åŒçš„å‡ºå£\r\n        // 1 ijæŒ‡çš„æ˜¯åŒä¸€ä¸ªæ–‡æœ¬èŠ‚ç‚¹ï¼ˆé‚£ä¹ˆå°±åªæœ‰è¿™ä¸€ç§æƒ…å†µï¼‰\r\n        // 2 ijæŒ‡çš„æ˜¯ä¸åŒçš„æ–‡æœ¬èŠ‚ç‚¹ï¼ˆè¿™å¥½åƒæ˜¯ä¸å¯èƒ½çš„ï¼‰\r\n\r\n        // ç°åœ¨ä»…æ˜¯æ‹¿åˆ°äº†æ–‡æœ¬èŠ‚ç‚¹ï¼Œè¿˜å¾—æ‹¿åˆ°é€‰ä¸­å¾—æ–‡æœ¬èŠ‚ç‚¹åœ¨è¯¥æ–‡æœ¬èŠ‚ç‚¹å¾—æ–‡æœ¬åç§»é‡\r\n        console.log(nodeIndexStart)\r\n        console.log(parent.childNodes)\r\n        console.log(parent.childNodes[nodeIndexStart], childIndexStart - length3, childIndexend - length3)\r\n\r\n        // ç©ºèŠ‚ç‚¹çš„é—®é¢˜ï¼ï¼ï¼ï¼ï¼\r\n\r\n        // é€šè¿‡ä¼ è¿›æ¥çš„æ–‡æœ¬åç§»é‡å®šä½åˆ°è¯¥markçš„æ•°æ®ï¼Œè¿™é‡Œè‚¯å®šä¸èƒ½æ˜¯è¿™ä¹ˆç®€å•çš„å†™\r\n        return splitNode(parent.childNodes[nodeIndexStart], childIndexStart - length3, childIndexend - length3)\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {*} header\r\n     * å¤„ç†å¤´éƒ¨èŠ‚ç‚¹ \r\n     */\r\n    const splitHeader = (header) => {\r\n\r\n        header.node.splitText(header.offset)\r\n        return header.node.nextSibling\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {*} tail \r\n     * å¤„ç†å°¾éƒ¨èŠ‚ç‚¹\r\n     */\r\n    const splitTail = (tail) => {\r\n        return tail.node.splitText(tail.offset).previousSibling\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {*} node \r\n     * @param {*} header \r\n     * @param {*} tail \r\n     * é¦–å°¾åœ¨ä¸€ä¸ªèŠ‚ç‚¹çš„æƒ…å†µ\r\n     */\r\n    const splitNode = (node, header, tail) => {\r\n        let newNode = node.splitText(header)\r\n        newNode.splitText(tail - header)\r\n        return newNode\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {*} node\r\n     * æ‹¿çˆ¶èŠ‚ç‚¹ \r\n     */\r\n    const findFatherNode = (node) => {\r\n        return node.parentNode\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {*} node \r\n     * @param {*} endNode \r\n     *  dfsæ”¶é›†\r\n     */\r\n    const collectTextNode = (node, endNode) => {\r\n        // dfs\r\n        if (node.nodeType === 3) {\r\n            pushTextNode(node)\r\n        } else {\r\n            let childNodes = node.childNodes\r\n            if (childNodes) {\r\n                for (let i = 0; i < childNodes.length; i++) {\r\n                    if (childNodes[i].nodeType === 3) {\r\n                        pushTextNode(childNodes[i])\r\n                        if (childNodes[i] == endNode) {\r\n                            flag = 1\r\n                            return\r\n                        }\r\n                    } else {\r\n                        collectTextNode(childNodes[i], endNode)\r\n                    }\r\n                }\r\n            } else {\r\n                return\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {*} node\r\n     * markæ”¶é›† ï¼Œè‚¯å®šæœ‰é‡å¤æ”¶é›†çš„é—®é¢˜\r\n     */\r\n    const pushTextNode = (node) => {\r\n        if (markArr.findIndex(item => node === item) === -1) {\r\n            markArr.push(node)\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {*} node \r\n     * @param {*} endNode \r\n     * æ‰¾äº²å”å”ğŸ˜€\r\n     */\r\n    const findUncle = (node, endNode) => {\r\n        if (node == markRef.current) {\r\n            return\r\n        }\r\n        let currentNode = node\r\n        // åˆ°å¤´äº†å°±æ‰¾å®ƒçˆ¶äº²çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹\r\n        let current_fa = findFatherNode(currentNode)\r\n        // çœ‹å®ƒè€å­æ˜¯ä¸æ˜¯å½“å‰èŠ‚ç‚¹çš„æœ€åä¸€ä¸ªå‘¢  (â•¯â€µâ–¡â€²)â•¯ç‚¸å¼¹ï¼â€¢â€¢â€¢*ï½â—\r\n        if (current_fa.nextSibling) {\r\n            collectTextNode(current_fa.nextSibling, endNode)\r\n            if (flag == 1) {\r\n                return\r\n            } else {\r\n                currentNode = current_fa.nextSibling\r\n                while (currentNode.nextSibling != null && flag === 0) {\r\n                    collectTextNode(currentNode.nextSibling, endNode)\r\n                    currentNode = currentNode.nextSibling\r\n                }\r\n                if (flag == 0) {\r\n                    collectTextNode(currentNode, endNode)\r\n                    findUncle(currentNode, endNode)\r\n                } else {\r\n                    return\r\n                }\r\n            }\r\n        } else {\r\n            collectTextNode(currentNode, endNode)\r\n            findUncle(current_fa, endNode)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param {*} start \r\n     * @param {*} end \r\n     * domæ ‘éå†\r\n     */\r\n    const traversalDom = (start, end) => {\r\n        let currentNode = start.node\r\n        if (currentNode.nextSibling) {\r\n            while (currentNode != end.node && currentNode.nextSibling != null) {\r\n                collectTextNode(currentNode, end.node)\r\n                currentNode = currentNode.nextSibling\r\n            }\r\n\r\n            if (flag == 0) {\r\n                collectTextNode(currentNode, end.node)\r\n                findUncle(currentNode, end.node)\r\n            } else {\r\n                return\r\n            }\r\n        } else {\r\n            collectTextNode(currentNode, end.node)\r\n            findUncle(currentNode, end.node)\r\n        }\r\n\r\n    }\r\n\r\n    return (\r\n        <div ref={markRef} onMouseUp={electoral}>\r\n            {children}\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default Mark;","D:\\mycode\\react-mark\\src\\util.js\\getDomRange.js",[],["34","35"],{"ruleId":"36","replacedBy":"37"},{"ruleId":"38","replacedBy":"39"},{"ruleId":"40","severity":1,"message":"41","line":26,"column":9,"nodeType":"42","messageId":"43","endLine":26,"endColumn":19},{"ruleId":"44","severity":1,"message":"45","line":26,"column":22,"nodeType":"46","endLine":26,"endColumn":24},{"ruleId":"40","severity":1,"message":"47","line":111,"column":13,"nodeType":"42","messageId":"43","endLine":111,"endColumn":23},{"ruleId":"40","severity":1,"message":"48","line":125,"column":15,"nodeType":"42","messageId":"43","endLine":125,"endColumn":30},{"ruleId":"40","severity":1,"message":"49","line":212,"column":17,"nodeType":"42","messageId":"43","endLine":212,"endColumn":29},{"ruleId":"50","severity":1,"message":"51","line":299,"column":43,"nodeType":"52","messageId":"53","endLine":299,"endColumn":45},{"ruleId":"50","severity":1,"message":"51","line":332,"column":18,"nodeType":"52","messageId":"53","endLine":332,"endColumn":20},{"ruleId":"50","severity":1,"message":"51","line":341,"column":22,"nodeType":"52","messageId":"53","endLine":341,"endColumn":24},{"ruleId":"50","severity":1,"message":"51","line":349,"column":26,"nodeType":"52","messageId":"53","endLine":349,"endColumn":28},{"ruleId":"50","severity":1,"message":"54","line":371,"column":32,"nodeType":"52","messageId":"53","endLine":371,"endColumn":34},{"ruleId":"50","severity":1,"message":"51","line":376,"column":22,"nodeType":"52","messageId":"53","endLine":376,"endColumn":24},{"ruleId":"36","replacedBy":"55"},{"ruleId":"38","replacedBy":"56"},"no-native-reassign",["57"],"no-negated-in-lhs",["58"],"no-unused-vars","'allMarkArr' is assigned a value but never used.","Identifier","unusedVar","react-hooks/exhaustive-deps","Assignments to the 'allMarkArr' variable from inside React Hook useEffect will be lost after each render. To preserve the value over time, store it in a useRef Hook and keep the mutable value in the '.current' property. Otherwise, you can move this variable directly inside useEffect.","ArrayExpression","'childIndex' is assigned a value but never used.","'calcRightLength' is assigned a value but never used.","'nodeIndexEnd' is assigned a value but never used.","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","Expected '!==' and instead saw '!='.",["57"],["58"],"no-global-assign","no-unsafe-negation"]